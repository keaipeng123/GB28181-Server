# 线程池笔记（结合 `ThreadPool` 代码）

> 对应文件：
>
> - `SipSupService/include/ThreadPool.h`
> - `SipSupService/src/ThreadPool.cpp`
>
> 目标：弄清这份线程池如何“投递任务 → 唤醒线程 → 取任务执行”，以及互斥锁、信号量在里面各自负责什么。

---

## 1. 代码整体在做什么？（一句话版）

- `ThreadPool` 内部维护一个**任务队列** `m_taskQueue`
- 多个工作线程一直在 `mainThread()` 里循环：
  1) `sem_wait()` 等任务
  2) 加锁从队列取出一个任务
  3) 执行 `task->run()`，然后 `delete task`
- 外部通过 `postTask()`：
  1) 加锁把任务塞进队列
  2) `sem_post()` 通知/唤醒一个工作线程

这是一种经典的 **“队列 + 互斥锁 + 信号量”** 的线程池模型。

---

## 2. `ThreadTask`：任务抽象（虚基类）

```cpp
class ThreadTask {
public:
    virtual void run() = 0;
};
```

含义：

- 把“要在线程池里执行的工作”抽象成 `run()`
- 不同业务用不同派生类实现 `run()`

你在业务侧的常见写法：

```cpp
class MyTask : public ThreadTask {
public:
    void run() override {
        // do something
    }
};

pool.postTask(new MyTask());
```

**注意生命周期**：当前线程池在工作线程里 `delete task;`，所以任务对象必须用 `new` 创建（或保证可被 `delete`）。

---

## 3. `ThreadPool` 的关键成员

### 3.1 `m_taskQueue`：任务队列（static）

```cpp
static queue<ThreadTask*> m_taskQueue;
```

- 用于存放待执行任务
- **是 static**：意味着它是“类级别共享”的，不属于某个对象实例
  - 所有 `ThreadPool` 对象共享同一个队列

### 3.2 `m_queueLock`：互斥锁（static）

```cpp
static pthread_mutex_t m_queueLock;
```

- 保护共享队列的并发访问
- **也是 static**：因此同样是全类共享

### 3.3 `m_signalSem`：信号量（每个对象一份）

```cpp
sem_t m_signalSem;
```

- 用来“计数”有多少个任务可取
- 工作线程 `sem_wait()` 会阻塞，直到有任务被 `sem_post()` 增加计数

---

## 4. 为什么要同时用“互斥锁 + 信号量”？

### 4.1 互斥锁的职责：保护队列这个共享数据结构

- 队列 `push/pop/front/size` 不是线程安全的
- 所以 `postTask()` 和 `mainThread()` 取任务时都必须加锁

### 4.2 信号量的职责：让线程“有任务才醒来”

如果没有信号量，工作线程就得不停轮询队列（busy loop），浪费 CPU。

信号量的好处：

- 没任务时：`sem_wait()` 睡眠阻塞
- 有任务时：`sem_post()` 唤醒一个等待线程

并且信号量是“计数”的：

- `postTask()` 多次 `sem_post()`，计数会累加
- 工作线程每次 `sem_wait()` 会消耗一个计数

---

## 5. 线程池创建流程：`createThreadPool()`

逻辑：

- 校验 `threadCount`
- 循环创建 `threadCount` 个线程，入口函数都是 `ThreadPool::mainThread`

细节：

```cpp
EC::ECThread::createThread(ThreadPool::mainThread, (void*)this, pid)
```

- 把 `this` 作为 `void*` 参数传给线程入口
- 在 `mainThread()` 里再强转回 `ThreadPool*` 使用

**重要结合点（和你之前的 `ECThread` 封装）**：

- `ECThread::createThread()` 目前创建的是 **detached** 线程
- 所以线程池里的工作线程是“后台线程”，不会被 join

---

## 6. 工作线程入口：`mainThread()` 的执行循环

核心循环：

1) `waitTask()`：内部 `sem_wait(&m_signalSem)` 阻塞等待
2) 被唤醒后，加锁访问队列
3) 从队列取出一个任务指针
4) 解锁
5) 执行 `task->run()`
6) `delete task`
7) `while(true)` 一直循环

这段代码反映了线程池的典型模式：

- **信号量控制“有没有任务”**
- **锁控制“取任务”**

---

## 7. `postTask()`：投递任务与唤醒线程

流程：

1) 加锁
2) `m_taskQueue.push(task)`
3) 解锁
4) `sem_post(&m_signalSem)`

### 7.1 为什么要“先 push 再 post”？

- 先把任务放进队列，再通知线程
- 避免出现“线程被唤醒了但队列还没放任务”的竞态（虽然有锁也能兜底，但顺序更合理）

---

## 8. 这份实现里最容易踩坑/可改进点

### 8.0 `static` 成员为什么必须在 `.cpp` 里“再写一遍”？（声明 vs 定义）

你在 `ThreadPool.h` 里写的：

```cpp
static queue<ThreadTask*> m_taskQueue;
```

这句通常只是**声明**：告诉编译器“类里有这个静态成员”，但并不会为它分配真正的存储空间。

而在 `ThreadPool.cpp` 里写的：

```cpp
queue<ThreadTask*> ThreadPool::m_taskQueue;
```

这句才是**定义（definition）**：

- 让链接器在整个程序中只生成“唯一一份”的 `ThreadPool::m_taskQueue`
- 并触发它的默认构造（`queue` 的构造）

如果缺少这条定义，常见后果是链接失败：`undefined reference to ThreadPool::m_taskQueue`。

补充：从 C++17 起可以用 `inline static` 把“定义”放到头文件里，避免单独 `.cpp` 定义；但你当前工程用的是传统写法，所以在 `.cpp` 定义一次是正常且必要的。

### 8.1 `createThreadPool()` 没有返回值（Bug/隐患）

函数声明是 `int createThreadPool(int threadCount);`，但实现里成功路径没有 `return 0;`。

- 这在 C++ 里是未定义/至少是错误用法
- 调用方可能拿到随机值

### 8.2 没有“停止线程池”的机制

`mainThread()` 是 `do { ... } while(true);` 无限循环。

后果：

- 没有优雅退出
- 线程池析构时销毁了 `m_queueLock` 和 `m_signalSem`，但工作线程可能还在跑/还在 `sem_wait()`，会产生不可预期行为

常见改法：

- 增加 `m_stop` 标志（原子/受锁保护）
- `postTask()` 之外提供 `stop()`：通过 `sem_post()` 唤醒所有线程，让其检测到 stop 后退出

### 8.3 `m_taskQueue` / `m_queueLock` 是 static（共享范围很大）

- 如果你创建多个 `ThreadPool` 对象，它们会共享同一个队列与锁
- 但每个对象却有自己的 `m_signalSem`

这会导致语义非常别扭：

- A 对象 `postTask()` 往共享队列塞任务，并 `sem_post(A.sem)`
- 但 B 对象的线程也可能去共享队列抢任务（只是被谁唤醒取决于谁的 sem）

一般更合理的是：

- 队列与锁是 **成员变量（非 static）**
- 每个线程池实例管理自己的队列、锁、条件

### 8.4 任务 `run()` 里的异常/崩溃风险

如果 `task->run()` 抛异常或崩溃：

- 可能导致线程直接退出
- 任务 `delete` 可能执行不到
- 线程池可用线程数减少

实务上通常会在线程入口包一层 `try/catch`，确保线程不会因业务异常直接死亡。

### 8.5 `waitTask()` 返回值处理

`sem_wait` 返回 0 表示成功；返回 -1 表示失败，并设置 `errno`（例如被信号中断 `EINTR`）。

当前实现：

- `waitTask()` 失败只打日志，但 `mainThread()` 仍会继续循环
- 如果出现 `EINTR`，通常可以选择重试

---

## 9. 你可以怎么用它做练习（建议）

1) 修复 `createThreadPool()` 的返回值：成功 `return 0;`，失败 `return -1;`
2) 练习写一个业务任务类（继承 `ThreadTask`）
3) 给线程池加一个 `stop()`：
   - `m_stop = true`
   - `sem_post` 多次唤醒所有工作线程
   - 工作线程检查 stop 并退出
4) 把 `m_taskQueue/m_queueLock` 改为非 static，让线程池实例互不干扰

---

## 10. 一张“执行流程图”（文字版）

- 主线程：
  - `postTask(task)` → (lock) push → (unlock) → `sem_post`

- 工作线程（循环）：
  - `sem_wait` 阻塞 → 被唤醒 → (lock) pop → (unlock) → `task->run()` → `delete task`
