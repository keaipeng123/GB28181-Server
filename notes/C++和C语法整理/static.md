# static 关键字（C / C++）

## 目录
- [1. static 是什么？](#1-static-是什么)
- [2. static 可以修饰什么？](#2-static-可以修饰什么)
- [3. C 语言中的 static：用法与关键概念](#3-c-语言中的-static用法与关键概念)
- [4. 修饰局部变量：静态局部变量](#4-修饰局部变量静态局部变量)
- [5. 默认初始化为 0：静态存储区特性](#5-默认初始化为-0静态存储区特性)
- [6. 修饰全局变量/函数：内部链接（文件作用域）](#6-修饰全局变量函数内部链接文件作用域)
- [7. 速查表](#7-速查表)

## 1. static 是什么？

`static` 是 C/C++ 的关键字之一，常用于修饰变量/函数（C++ 里还包括类的静态成员），用来控制：

- **存储方式**（变量放在哪个存储区 / 生命周期多长）
- **作用域与链接属性**（在其他源文件里能不能“看见/使用”）

![内存分区](../assets/截屏2026-01-26%2017.19.10.png)

## 2. static 可以修饰什么？

- 局部变量
- 全局变量
- 函数

> [!NOTE]
> 本文重点按 C 语言语境讲解；C++ 的类静态成员（`static member`）不在本文展开。

## 3. C 语言中的 static：用法与关键概念

### 3.1 三种常见用法

1. 修饰局部变量（静态局部变量）
2. 修饰全局变量（静态全局变量）
3. 修饰函数（静态函数）

### 3.2 重点概念（记住这 5 点）

1. **只初始化一次**：函数内的 `static` 局部变量只会在程序生命周期内初始化一次，后续调用会保留上一次的值。
2. **静态存储期**：`static` 变量具有静态存储期，生命周期贯穿整个程序。
3. **内部链接**：在文件作用域（全局/命名空间范围）用 `static` 修饰的变量/函数具有内部链接，其他源文件无法 `extern` 引用。
4. **默认初始化为 0**：未显式初始化的静态存储期对象，默认会被置 0（或空字符 `\0`）。
5. **改变存储位置**：`static` 修饰局部变量时，不改变其作用域，但会让它从“栈上的自动存储期”变为“静态存储期”。

> [!TIP]
> 下面会分别用两个小例子把「局部变量持久化」与「内部链接」讲透。

## 4. 修饰局部变量：静态局部变量

### 4.1 普通局部变量（每次调用都重新创建）

```c
#include <stdio.h>

void test(void)
{
	int x = 0;
	x++;
	printf("%d ", x);
}

int main(void)
{
	int i = 0;
	while (i < 10)
	{
		test();
		i++;
	}
	return 0;
}
```

输出（易得）：

```text
1 1 1 1 1 1 1 1 1 1
```

原因：每次调用 `test()` 都会创建新的局部变量 `x`，函数返回后 `x` 立即销毁。

### 4.2 static 局部变量（只初始化一次，值会“记住”）

```c
#include <stdio.h>

void test(void)
{
	static int x = 0;
	x++;
	printf("%d ", x);
}

int main(void)
{
	int i = 0;
	while (i < 10)
	{
		test();
		i++;
	}
	return 0;
}
```

输出：

```text
1 2 3 4 5 6 7 8 9 10
```

原因：`x` 变为静态局部变量，只会初始化一次，并且函数结束后不销毁，下一次进入 `test()` 时仍保留上次的数值。

![内存分区改变](../assets/截屏2026-01-26%2017.31.13.png)

> [!NOTE]
> - `static` 修饰局部变量：**作用域不变**（仍在函数内部可见），但**生命周期变长**（贯穿整个程序）。
> - 本质是存储位置变化：普通局部变量通常在栈区，`static` 局部变量在静态存储区。

## 5. 默认初始化为 0：静态存储区特性

这里用一个例子看“未初始化时的默认值差异”：

```c
#include <stdio.h>

int a;  // 全局变量：静态存储期，默认初始化为 0

int main(void)
{
	char str[10]; // 栈上局部数组：未初始化，内容不确定
	printf("integer: %d; string: (begin)%s(end)\n", a, str);
	return 0;
}
```

> [!WARNING]
> `str` 未初始化就按 `%s` 打印是未定义行为（UB），示例仅用于说明“栈上未初始化内容不确定”。

如果把两者都改成静态存储期：

```c
#include <stdio.h>

static int a;

int main(void)
{
	static char str[10];
	printf("integer: %d; string: (begin)%s(end)\n", a, str);
	return 0;
}
```

此时 `a == 0`，`str` 的每个字节默认都是 `0x00`，因此作为字符串打印时通常会是空串。

> [!NOTE]
> “默认初始化为 0”对稀疏矩阵、清零缓冲区等场景很省事；静态字符数组也天然以 `\0` 填充。

## 6. 修饰全局变量/函数：内部链接（文件作用域）

当变量/函数定义在文件作用域时：

- **默认是外部链接**：其他源文件可用 `extern` 声明后在链接阶段引用。
- **加上 `static` 后变内部链接**：只能在当前源文件内使用，其他文件“看不见”。

### 6.1 extern 引用（外部链接）示意

![extern例子](../assets/截屏2026-01-27%2015.03.44.png)

![extern运行结果](../assets/截屏2026-01-27%2015.30.20.png)

### 6.2 加 static 后（内部链接）示意

![extern运行结果](../assets/截屏2026-01-27%2015.32.28.png)

现象：链接阶段会报错（例如“无法解析外部符号”），因为被 `static` 修饰后，符号不再对其他源文件可见。

> [!NOTE]
> 这个特性常用来：
> - **限制可见性**：只让本文件使用，避免被误用
> - **避免命名冲突**：不同 `.c` 文件可以各自拥有同名的 `static` 函数/变量

## 7. 速查表

| 修饰对象 | 放在什么位置（直观理解） | 作用域/可见性变化 | 最常见效果 |
|---|---|---|---|
| 局部变量 `static int x;` | 静态存储区 | 作用域不变（仍在函数内） | 值会“记住”，跨调用保留 |
| 全局变量 `static int g;` | 静态存储区 | 外部链接 → 内部链接 | 其他文件无法 `extern` 访问 |
| 函数 `static void f();` | 代码区（函数本体不变） | 外部链接 → 内部链接 | 仅本文件可调用，避免冲突 |