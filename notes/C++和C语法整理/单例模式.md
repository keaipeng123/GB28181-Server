# 单例模式（结合 `GlobalCtl` 代码）

> 单例（Singleton）的目标：**整个进程中某个类型只存在一个实例**，并提供一个全局可访问点。
>
> 下面结合工程里的 `GlobalCtl`（见 `SipSupService/include/GlobalCtl.h` 与 `SipSupService/src/GlobalCtl.cpp`）来拆解它的实现思路、优缺点与改进方式。

---

## 1. 这份 `GlobalCtl` 单例在做什么？（代码结构总览）

### 1.1 关键成员

- `static GlobalCtl* m_pInstance;`
  - **类静态指针**：用于保存“唯一实例”的地址。
  - 因为是 `static` 成员，所以它不属于某个对象，而是属于整个类。

- `static GlobalCtl* instance();`
  - **全局访问点**：外部通过 `GlobalCtl::instance()` 获取单例。

### 1.2 关键限制

- 构造函数 `GlobalCtl()` 是 `private`
  - 阻止外部 `new GlobalCtl()`。

- 拷贝构造与赋值运算符在 `private` 区域声明（旧式写法）
  - `GlobalCtl(const GlobalCtl&);`
  - `const GlobalCtl& operator=(const GlobalCtl&);`
  - 目的：阻止 `GlobalCtl a = *GlobalCtl::instance();` 或 `*p = other;` 这种“复制出第二份实例”的行为。

> 说明：现代 C++ 更推荐用 `= delete` 显式禁用（见第 5 节）。

---

## 2. `m_pInstance` 为什么要在 `.cpp` 里定义？

在头文件 `GlobalCtl.h` 里只是“声明”了：

```cpp
static GlobalCtl* m_pInstance;
```

但 **类的静态数据成员**必须在某一个 `.cpp` 文件里给出**唯一一次定义**，否则会链接失败。

所以在 `GlobalCtl.cpp` 里有：

```cpp
GlobalCtl* GlobalCtl::m_pInstance = NULL;
```

这行就是“定义并初始化”。

---

## 3. `instance()` 的单例逻辑是怎么保证“只有一个”的？

`GlobalCtl::instance()`：

```cpp
GlobalCtl* GlobalCtl::instance()
{
    if(!m_pInstance)
    {
        m_pInstance = new GlobalCtl();
    }
    return m_pInstance;
}
```

逐句解释：

1) `if(!m_pInstance)`
- 第一次调用 `instance()` 时，`m_pInstance` 还是空指针，于是进入分支创建对象。

2) `m_pInstance = new GlobalCtl();`
- 调用私有构造函数创建对象。
- 地址保存到类静态指针 `m_pInstance`。

3) `return m_pInstance;`
- 以后每次调用都会直接返回同一个指针。

这种写法叫：

- **懒汉式（Lazy Initialization）**：第一次用到才创建。

---

## 4. `GBOJ(obj)` 这个宏在做什么？有什么风险？

```cpp
#define GBOJ(obj) GlobalCtl::instance()->obj
```

目的：简化访问，比如：

```cpp
GBOJ(gConfig)->localIp();
```

等价于：

```cpp
GlobalCtl::instance()->gConfig->localIp();
```

注意点：

- 宏是文本替换，`GBOJ(x++)` 这类带副作用的参数会很危险（一般别这么写）。
- 宏不做类型检查、也不受作用域约束；更推荐用 `inline` 函数或直接写清楚。

---

## 5. 这份单例实现的常见问题（非常重要）

### 5.1 线程不安全（多线程下可能创建出两个实例）

当前实现：

- 线程 A 进入 `if (!m_pInstance)`，准备 new
- 线程 B 同时也进入 `if (!m_pInstance)`，也准备 new

最终可能 new 出两个对象，其中一个地址被覆盖，造成 **内存泄漏 + 单例失效**。

> 如果你的服务有多线程（GB28181/网络服务通常会有），这个点要重点关注。

### 5.2 内存释放/析构时机不明确（可能泄漏）

`new GlobalCtl()` 创建的对象没有对应 `delete`。

- 进程结束时 OS 会回收内存，但析构函数可能不会被调用到（尤其是你把析构函数设为 private 时更难手动释放）。
- 如果 `GlobalCtl` 未来持有 socket、文件句柄、线程等资源，退出时可能无法优雅释放。

### 5.3 “禁用拷贝/赋值”的写法是旧式技巧

现在这样写：只在 `private` 声明，不实现。

- 优点：老编译器也能用。
- 缺点：报错通常发生在链接期（有时不够直观）。

现代 C++ 推荐：

```cpp
GlobalCtl(const GlobalCtl&) = delete;
GlobalCtl& operator=(const GlobalCtl&) = delete;
```

### 5.4 `init(void* param)` 的类型安全问题

```cpp
gConfig = (SipLocalConfig*)param;
```

- `void*` 需要手动转换，类型不安全。
- 如果传错类型或生命周期不对，运行时才崩。

更推荐：

- 直接写 `bool init(SipLocalConfig* cfg)`
- 或用引用 `bool init(SipLocalConfig& cfg)`（明确所有权/生命周期）

---

## 6. 更推荐的单例写法（C++11 起）

### 6.1 Meyers Singleton（函数内静态对象）

C++11 起，函数内 `static` 的初始化**保证线程安全**：

```cpp
class GlobalCtl {
public:
    static GlobalCtl& instance() {
        static GlobalCtl inst; // 线程安全初始化（C++11 起）
        return inst;
    }

    GlobalCtl(const GlobalCtl&) = delete;
    GlobalCtl& operator=(const GlobalCtl&) = delete;

private:
    GlobalCtl() = default;
    ~GlobalCtl() = default;
};
```

优点：

- 不需要 `new`，避免“释放时机”问题
- C++11 起线程安全
- 代码更短，错误更少

注意：

- 这种返回引用的接口更常见：`GlobalCtl::instance().gConfig`。

### 6.2 如果必须返回指针

也可以返回 `GlobalCtl*`，但内部仍用函数内静态对象：

```cpp
static GlobalCtl* instance() {
    static GlobalCtl inst;
    return &inst;
}
```

---

## 7. 知识点总结（记忆版）

- 单例三件套：
  - 私有构造（阻止外部创建）
  - 全局访问点（`instance()`）
  - 禁用拷贝/赋值（阻止复制）

- 懒汉式：第一次调用才创建；要考虑**线程安全**。

- `new` 版单例要考虑：
  - 释放时机（泄漏/析构顺序）
  - 线程并发创建

- C++11 推荐：函数内 `static`（Meyers Singleton），线程安全、生命周期自动管理。

- `void*` 参数会损失类型安全；能用强类型就别用 `void*`。
